import contextlib
import json
import os
import signal
import sys
import time
from dataclasses import dataclass
from pathlib import Path
from subprocess import DEVNULL, PIPE

import ape
import eth_account
import psutil
import yaml
from ape_test.accounts import TestAccount
from eth_utils import to_checksum_address
from yaml.loader import SafeLoader

from beamer.agent.agent import Agent
from beamer.agent.config import ChainConfig, Config
from beamer.agent.util import TokenChecker
from beamer.tests.agent.utils import generate_abi_files
from beamer.tests.util import Sleeper
from beamer.typing import URL, ChainId
from beamer.util import make_web3, transact

_SLAVE_TEST_PATH = Path(__file__).parent / "_test_slave.py"
_CONFIG_PATH = ape.project.local_project.path / ape.project.local_project.config_file_name


@dataclass
class _ChainInfo:
    port: int
    is_legacy: bool


def _start_ganache(chain_id: ChainId, port: int, is_legacy: bool = True) -> psutil.Popen:
    cmd = [
        "ganache",
        "--chain.vmErrorsOnRPCResponse",
        "true",
        "--server.port",
        str(port),
        "--miner.blockGasLimit",
        "12000000",
        "--wallet.totalAccounts",
        "10",
        "--wallet.mnemonic",
        "brownie",
        "--chain.chainId",
        str(chain_id),
    ]
    if is_legacy:
        cmd += ["--hardfork", "istanbul"]
    return psutil.Popen(cmd, stdin=DEVNULL, stdout=PIPE, stderr=PIPE)


@contextlib.contextmanager
def _configure_ganache_port(port: int):
    with open(_CONFIG_PATH) as f:
        current_config = yaml.load(f, Loader=SafeLoader)
    backup_path = _CONFIG_PATH.parent / "ape-config.yaml.original"
    os.rename(_CONFIG_PATH, backup_path)
    current_config["ganache"]["server"]["port"] = port
    with open(_CONFIG_PATH, "w") as f:
        yaml.dump(current_config, f, sort_keys=False, default_flow_style=False)
    try:
        yield
    finally:
        os.rename(backup_path, _CONFIG_PATH)


def _start_slave_test(
    first_chain_id: ChainId, port: int, request_count: int, artifacts_dir: Path
) -> psutil.Popen:
    return psutil.Popen(
        ["ape", "test", str(_SLAVE_TEST_PATH), "-s"],
        stdin=PIPE,
        stdout=PIPE,
        stderr=PIPE,
        env=dict(
            os.environ,
            PORT=str(port),
            REQUEST_COUNT=str(request_count),
            FIRST_CHAIN_ID=str(first_chain_id),
            ARTIFACTS_DIR=str(artifacts_dir),
        ),
    )


@contextlib.contextmanager
def _new_networks(chain_port_map: dict[ChainId, _ChainInfo]):
    processes = {}
    try:
        for chain_id, chain_info in chain_port_map.items():
            processes[chain_id] = _start_ganache(chain_id, chain_info.port, chain_info.is_legacy)
        yield
    finally:
        for process in processes.values():
            os.kill(process.pid, signal.SIGKILL)
            process.wait()


def _get_chain_map() -> dict[ChainId, _ChainInfo]:
    number_of_chains = 4
    return {ChainId(i): _ChainInfo(i, True) for i in range(8546, 8546 + number_of_chains)}


def _get_config(
    tmp_path: Path,
    chain_map: dict[ChainId, _ChainInfo],
    slave_contract_addresses: dict[ChainId, dict[str, str]],
    local_account: TestAccount,
) -> Config:
    account = eth_account.Account.from_key(local_account.private_key)
    url = ape.config.provider.uri

    abi_dir = tmp_path / "abis"
    generate_abi_files(abi_dir)

    # Artifacts are generated by slave test instances.
    artifacts_dir = tmp_path / "artifacts"

    chains = {}
    for chain_id, chain_info in chain_map.items():
        chains[str(chain_id)] = ChainConfig(
            rpc_url=URL(f"http://127.0.0.1:{chain_info.port}"),
            min_source_balance=0,
            confirmation_blocks=0,
            poll_period=1.0,
        )

    token_list = _get_token_list(chain_map, slave_contract_addresses)
    config = Config(
        abi_dir=abi_dir,
        artifacts_dir=artifacts_dir,
        base_chain_rpc_url=url,
        token_checker=TokenChecker(token_list),
        account=account,
        fill_wait_time=0,
        unsafe_fill_time=600,
        prometheus_metrics_port=None,
        log_level="debug",
        chains=chains,
    )
    return config


def _start_agent_test(config: Config):
    agent = Agent(config)
    agent.start()

    directions = agent.get_directions()
    try:
        for direction in directions:
            with Sleeper(20) as sleeper:
                while len(agent.get_context(direction).requests) != 1:
                    sleeper.sleep(0.1)

            request = next(iter(agent.get_context(direction).requests))

            with Sleeper(20) as sleeper:
                while not request.claimed.is_active:
                    sleeper.sleep(0.1)
    finally:
        agent.stop()


def _get_slave_contract_addresses(proc: psutil.Popen) -> dict[str, str]:
    stdout = ""
    while proc.status() in [
        psutil.STATUS_RUNNING,
        psutil.STATUS_IDLE,
        psutil.STATUS_SLEEPING,
        psutil.STATUS_DISK_SLEEP,
    ]:
        line = proc.stdout.readline().decode()
        stdout += line
        if "Chain is ready\n" == line:
            proc.stdin.write("get_contracts\n".encode())
            proc.stdin.flush()
            line = proc.stdout.readline().decode()
            contract_addresses = json.loads(line)
            return contract_addresses
    sys.stderr.write("Slave process exited before detecting contract addresses!\n")
    sys.stderr.write(stdout)
    sys.stderr.flush()
    sys.exit(1)


def _stop_slave_tests(slave_procs: list[psutil.Popen]):
    for proc in slave_procs:
        os.kill(proc.pid, signal.SIGKILL)
        proc.wait()


def _get_token_list(
    chain_map: dict[ChainId, _ChainInfo], slave_contract_addresses: dict[ChainId, dict[str, str]]
) -> list[list[list[str]]]:
    tokens: list[list[str]] = []
    for chain_id in chain_map:
        tokens.append([str(chain_id), slave_contract_addresses[chain_id]["token"]])
    return [tokens]


def _mint_agent_tokens(
    config: Config,
    token: ape.project.MintableToken,
    slave_contract_addresses: dict[ChainId, dict[str, str]],
):
    for chain_name, chain_config in config.chains.items():
        w3 = make_web3(chain_config.rpc_url, config.account)
        while not w3.is_connected():
            time.sleep(1)
        l2_token = w3.eth.contract(
            address=to_checksum_address(
                slave_contract_addresses[ChainId(int(chain_name))]["token"]
            ),
            abi=[abi.dict() for abi in token.contract_type.abi],
        )
        transact(l2_token.functions.mint(config.account.address, 300))


def test_multiple_event_processors(
    tmp_path: Path, token: ape.project.MintableToken, local_account: TestAccount
):
    chain_map = _get_chain_map()
    artifacts_dir = tmp_path / "artifacts"
    with _new_networks(chain_map):
        slave_test_procs = []
        slave_contract_addresses: dict[ChainId, dict[str, str]] = {}
        for chain_id, chain_info in chain_map.items():
            with _configure_ganache_port(chain_info.port):
                slave = _start_slave_test(
                    min(chain_map.keys()), chain_info.port, len(chain_map), artifacts_dir
                )
                contract_addresses = _get_slave_contract_addresses(slave)
                slave_contract_addresses[chain_id] = contract_addresses
                slave_test_procs.append(slave)
        config = _get_config(tmp_path, chain_map, slave_contract_addresses, local_account)
        _mint_agent_tokens(config, token, slave_contract_addresses)
        _start_agent_test(config)
        _stop_slave_tests(slave_test_procs)


def _start_agent_fee_test(config: Config):
    agent = Agent(config)
    agent.start()

    directions = agent.get_directions()
    fee_map = {}
    try:
        for direction in directions:
            with Sleeper(20) as sleeper:
                while len(agent.get_context(direction).requests) != 1:
                    sleeper.sleep(0.1)

            context = agent.get_context(direction)
            request = next(iter(context.requests))

            with Sleeper(20) as sleeper:
                while request.fill_tx is None:
                    sleeper.sleep(0.1)

            receipt = context.fill_manager.w3.eth.get_transaction_receipt(request.fill_tx)
            fee_map[context.target_chain.id] = receipt["effectiveGasPrice"]
        # For chain id 1 type 2 transactions are used so fee is lower than legacy transactions
        assert min(fee_map.values()) == fee_map[ChainId(1)]
    finally:
        agent.stop()


def test_l1_base_fees(
    tmp_path: Path, token: ape.project.MintableToken, local_account: TestAccount
):
    chain_map = {ChainId(1): _ChainInfo(9545, False), ChainId(2): _ChainInfo(9546, True)}
    artifacts_dir = tmp_path / "artifacts"
    with _new_networks(chain_map):
        slave_test_procs = []
        slave_contract_addresses: dict[ChainId, dict[str, str]] = {}
        for chain_id, chain_info in chain_map.items():
            with _configure_ganache_port(chain_info.port):
                slave = _start_slave_test(
                    min(chain_map.keys()), chain_info.port, len(chain_map), artifacts_dir
                )
                contract_addresses = _get_slave_contract_addresses(slave)
                slave_contract_addresses[chain_id] = contract_addresses
                slave_test_procs.append(slave)
        config = _get_config(tmp_path, chain_map, slave_contract_addresses, local_account)
        _mint_agent_tokens(config, token, slave_contract_addresses)
        _start_agent_fee_test(config)
        _stop_slave_tests(slave_test_procs)
